/**
 * Generated by orval v7.3.0 üç∫
 * Do not edit manually.
 * Fittner API
 * Fittner API with Spring Boot
 * OpenAPI spec version: 1.0.0
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import type {
  ApiResponseMessageListTermsResDto,
  ApiResponseMessageObject,
  ApiResponseMessagePageResponseDtoCenterListResDto,
  ApiResponseMessagePageResponseDtoMainUserCenterListResDto,
  ApiResponseMessagePageResponseDtoMemberListResDto,
  ApiResponseMessagePageResponseDtoUserCenterListResDto,
  ApiResponseMessageUserInfoResDto,
  CancelCenterApprovalReqDto,
  CenterList1Params,
  CenterListParams,
  CenterRegisterReqDto,
  JoinReqDto,
  MainCenterListParams,
  MemberRegisterReqDto,
  MembersParams
} from '.././models'
import { axiosInstance } from '../../mutator/instance-wrapper';



/**
 * Ìä∏Î†àÏù¥ÎÑàÍ∞Ä ÌöåÏõêÏùÑ Îì±Î°ùÌïòÎäî API ÏûÖÎãàÎã§.
 * @summary Ìä∏Î†àÏù¥ÎÑàÍ∞Ä ÌöåÏõêÏùÑ Îì±Î°ùÌïòÎäî API
 */
export const register = (
    memberRegisterReqDto: MemberRegisterReqDto,
 signal?: AbortSignal
) => {
      
      
      return axiosInstance<ApiResponseMessageObject>(
      {url: `/api/v1/user/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: memberRegisterReqDto, signal
    },
      );
    }
  


export const getRegisterMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof register>>, TError,{data: MemberRegisterReqDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof register>>, TError,{data: MemberRegisterReqDto}, TContext> => {
const {mutation: mutationOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof register>>, {data: MemberRegisterReqDto}> = (props) => {
          const {data} = props ?? {};

          return  register(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterMutationResult = NonNullable<Awaited<ReturnType<typeof register>>>
    export type RegisterMutationBody = MemberRegisterReqDto
    export type RegisterMutationError = unknown

    /**
 * @summary Ìä∏Î†àÏù¥ÎÑàÍ∞Ä ÌöåÏõêÏùÑ Îì±Î°ùÌïòÎäî API
 */
export const useRegister = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof register>>, TError,{data: MemberRegisterReqDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof register>>,
        TError,
        {data: MemberRegisterReqDto},
        TContext
      > => {

      const mutationOptions = getRegisterMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Ìä∏Î†àÏù¥ÎÑà ÌöåÏõêÍ∞ÄÏûÖ API ÏûÖÎãàÎã§.
 * @summary Ìä∏Î†àÏù¥ÎÑà ÌöåÏõêÍ∞ÄÏûÖ API
 */
export const login = (
    joinReqDto: JoinReqDto,
 signal?: AbortSignal
) => {
      
      
      return axiosInstance<ApiResponseMessageObject>(
      {url: `/api/v1/user/join`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: joinReqDto, signal
    },
      );
    }
  


export const getLoginMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: JoinReqDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: JoinReqDto}, TContext> => {
const {mutation: mutationOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: JoinReqDto}> = (props) => {
          const {data} = props ?? {};

          return  login(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = JoinReqDto
    export type LoginMutationError = unknown

    /**
 * @summary Ìä∏Î†àÏù¥ÎÑà ÌöåÏõêÍ∞ÄÏûÖ API
 */
export const useLogin = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: JoinReqDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof login>>,
        TError,
        {data: JoinReqDto},
        TContext
      > => {

      const mutationOptions = getLoginMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Ìä∏Î†àÏù¥ÎÑàÏùò ÏÑºÌÑ∞ Îì±Î°ù API ÏûÖÎãàÎã§.
 * @summary Ìä∏Î†àÏù¥ÎÑàÏùò ÏÑºÌÑ∞ Îì±Î°ù API
 */
export const registerCenter = (
    centerRegisterReqDto: CenterRegisterReqDto,
 signal?: AbortSignal
) => {
      
      
      return axiosInstance<ApiResponseMessageObject>(
      {url: `/api/v1/user/center`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: centerRegisterReqDto, signal
    },
      );
    }
  


export const getRegisterCenterMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerCenter>>, TError,{data: CenterRegisterReqDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof registerCenter>>, TError,{data: CenterRegisterReqDto}, TContext> => {
const {mutation: mutationOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registerCenter>>, {data: CenterRegisterReqDto}> = (props) => {
          const {data} = props ?? {};

          return  registerCenter(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterCenterMutationResult = NonNullable<Awaited<ReturnType<typeof registerCenter>>>
    export type RegisterCenterMutationBody = CenterRegisterReqDto
    export type RegisterCenterMutationError = unknown

    /**
 * @summary Ìä∏Î†àÏù¥ÎÑàÏùò ÏÑºÌÑ∞ Îì±Î°ù API
 */
export const useRegisterCenter = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerCenter>>, TError,{data: CenterRegisterReqDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof registerCenter>>,
        TError,
        {data: CenterRegisterReqDto},
        TContext
      > => {

      const mutationOptions = getRegisterCenterMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Ìä∏Î†àÏù¥ÎÑà Î≥∏Ïù∏Ïù¥ ÏäπÏù∏ÏöîÏ≤≠ÌïúÍ±∏ ÏäπÏù∏Ï∑®ÏÜåÌïòÎäî API ÏûÖÎãàÎã§.
 * @summary Ìä∏Î†àÏù¥ÎÑà Î≥∏Ïù∏Ïù¥ ÏäπÏù∏ÏöîÏ≤≠ÌïúÍ±∏ ÏäπÏù∏Ï∑®ÏÜåÌïòÎäî API
 */
export const cancelCenterApproval = (
    cancelCenterApprovalReqDto: CancelCenterApprovalReqDto,
 ) => {
      
      
      return axiosInstance<ApiResponseMessageObject>(
      {url: `/api/v1/user/center`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: cancelCenterApprovalReqDto
    },
      );
    }
  


export const getCancelCenterApprovalMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelCenterApproval>>, TError,{data: CancelCenterApprovalReqDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof cancelCenterApproval>>, TError,{data: CancelCenterApprovalReqDto}, TContext> => {
const {mutation: mutationOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancelCenterApproval>>, {data: CancelCenterApprovalReqDto}> = (props) => {
          const {data} = props ?? {};

          return  cancelCenterApproval(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CancelCenterApprovalMutationResult = NonNullable<Awaited<ReturnType<typeof cancelCenterApproval>>>
    export type CancelCenterApprovalMutationBody = CancelCenterApprovalReqDto
    export type CancelCenterApprovalMutationError = unknown

    /**
 * @summary Ìä∏Î†àÏù¥ÎÑà Î≥∏Ïù∏Ïù¥ ÏäπÏù∏ÏöîÏ≤≠ÌïúÍ±∏ ÏäπÏù∏Ï∑®ÏÜåÌïòÎäî API
 */
export const useCancelCenterApproval = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelCenterApproval>>, TError,{data: CancelCenterApprovalReqDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof cancelCenterApproval>>,
        TError,
        {data: CancelCenterApprovalReqDto},
        TContext
      > => {

      const mutationOptions = getCancelCenterApprovalMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * ÏïΩÍ¥Ä Ï°∞Ìöå API ÏûÖÎãàÎã§.
 * @summary ÏïΩÍ¥Ä Ï°∞Ìöå API
 */
export const getTerms = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosInstance<ApiResponseMessageListTermsResDto>(
      {url: `/api/v1/user/terms`, method: 'GET', signal
    },
      );
    }
  

export const getGetTermsQueryKey = () => {
    return [`/api/v1/user/terms`] as const;
    }

    
export const getGetTermsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getTerms>>>, TError = unknown>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTerms>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTermsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTerms>>> = ({ signal }) => getTerms(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTerms>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTermsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTerms>>>
export type GetTermsInfiniteQueryError = unknown


export function useGetTermsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTerms>>>, TError = unknown>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTerms>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTerms>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTermsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTerms>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTerms>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTerms>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTermsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTerms>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTerms>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary ÏïΩÍ¥Ä Ï°∞Ìöå API
 */

export function useGetTermsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTerms>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTerms>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTermsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTermsQueryOptions = <TData = Awaited<ReturnType<typeof getTerms>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTerms>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTermsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTerms>>> = ({ signal }) => getTerms(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTerms>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTermsQueryResult = NonNullable<Awaited<ReturnType<typeof getTerms>>>
export type GetTermsQueryError = unknown


export function useGetTerms<TData = Awaited<ReturnType<typeof getTerms>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTerms>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTerms>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTerms<TData = Awaited<ReturnType<typeof getTerms>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTerms>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTerms>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTerms<TData = Awaited<ReturnType<typeof getTerms>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTerms>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary ÏïΩÍ¥Ä Ï°∞Ìöå API
 */

export function useGetTerms<TData = Awaited<ReturnType<typeof getTerms>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTerms>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTermsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Ìä∏Î†àÏù¥ÎÑàÏùò ÌöåÏõê Î™©Î°ù Ï°∞Ìöå API ÏûÖÎãàÎã§.
 * @summary Ìä∏Î†àÏù¥ÎÑàÏùò ÌöåÏõê Î™©Î°ù Ï°∞Ìöå API
 */
export const members = (
    params: MembersParams,
 signal?: AbortSignal
) => {
      
      
      return axiosInstance<ApiResponseMessagePageResponseDtoMemberListResDto>(
      {url: `/api/v1/user/members`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getMembersQueryKey = (params: MembersParams,) => {
    return [`/api/v1/user/members`, ...(params ? [params]: [])] as const;
    }

    
export const getMembersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof members>>, MembersParams['page']>, TError = unknown>(params: MembersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof members>>, TError, TData, Awaited<ReturnType<typeof members>>, QueryKey, MembersParams['page']>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMembersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof members>>, QueryKey, MembersParams['page']> = ({ signal, pageParam }) => members({...params, page: pageParam || params?.['page']}, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof members>>, TError, TData, Awaited<ReturnType<typeof members>>, QueryKey, MembersParams['page']> & { queryKey: DataTag<QueryKey, TData> }
}

export type MembersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof members>>>
export type MembersInfiniteQueryError = unknown


export function useMembersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof members>>, MembersParams['page']>, TError = unknown>(
 params: MembersParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof members>>, TError, TData, Awaited<ReturnType<typeof members>>, QueryKey, MembersParams['page']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof members>>,
          TError,
          TData, QueryKey
        > , 'initialData'
      >, }

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useMembersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof members>>, MembersParams['page']>, TError = unknown>(
 params: MembersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof members>>, TError, TData, Awaited<ReturnType<typeof members>>, QueryKey, MembersParams['page']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof members>>,
          TError,
          TData, QueryKey
        > , 'initialData'
      >, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useMembersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof members>>, MembersParams['page']>, TError = unknown>(
 params: MembersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof members>>, TError, TData, Awaited<ReturnType<typeof members>>, QueryKey, MembersParams['page']>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Ìä∏Î†àÏù¥ÎÑàÏùò ÌöåÏõê Î™©Î°ù Ï°∞Ìöå API
 */

export function useMembersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof members>>, MembersParams['page']>, TError = unknown>(
 params: MembersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof members>>, TError, TData, Awaited<ReturnType<typeof members>>, QueryKey, MembersParams['page']>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getMembersInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getMembersQueryOptions = <TData = Awaited<ReturnType<typeof members>>, TError = unknown>(params: MembersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof members>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMembersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof members>>> = ({ signal }) => members(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof members>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type MembersQueryResult = NonNullable<Awaited<ReturnType<typeof members>>>
export type MembersQueryError = unknown


export function useMembers<TData = Awaited<ReturnType<typeof members>>, TError = unknown>(
 params: MembersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof members>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof members>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useMembers<TData = Awaited<ReturnType<typeof members>>, TError = unknown>(
 params: MembersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof members>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof members>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useMembers<TData = Awaited<ReturnType<typeof members>>, TError = unknown>(
 params: MembersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof members>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Ìä∏Î†àÏù¥ÎÑàÏùò ÌöåÏõê Î™©Î°ù Ï°∞Ìöå API
 */

export function useMembers<TData = Awaited<ReturnType<typeof members>>, TError = unknown>(
 params: MembersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof members>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getMembersQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Ìä∏Î†àÏù¥ÎÑàÍ∞Ä ÏßÄÏ†ïÌïú ÏÑºÌÑ∞ Î™©Î°ù Ï°∞Ìöå API ÏûÖÎãàÎã§.
 * @summary Î©îÏù∏ÏóêÏÑú Ìä∏Î†àÏù¥ÎÑàÍ∞Ä ÏßÄÏ†ïÌïú ÏÑºÌÑ∞ Î™©Î°ù Ï°∞Ìöå API
 */
export const mainCenterList = (
    params: MainCenterListParams,
 signal?: AbortSignal
) => {
      
      
      return axiosInstance<ApiResponseMessagePageResponseDtoMainUserCenterListResDto>(
      {url: `/api/v1/user/main/centers`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getMainCenterListQueryKey = (params: MainCenterListParams,) => {
    return [`/api/v1/user/main/centers`, ...(params ? [params]: [])] as const;
    }

    
export const getMainCenterListInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof mainCenterList>>, MainCenterListParams['page']>, TError = unknown>(params: MainCenterListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof mainCenterList>>, TError, TData, Awaited<ReturnType<typeof mainCenterList>>, QueryKey, MainCenterListParams['page']>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMainCenterListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof mainCenterList>>, QueryKey, MainCenterListParams['page']> = ({ signal, pageParam }) => mainCenterList({...params, page: pageParam || params?.['page']}, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof mainCenterList>>, TError, TData, Awaited<ReturnType<typeof mainCenterList>>, QueryKey, MainCenterListParams['page']> & { queryKey: DataTag<QueryKey, TData> }
}

export type MainCenterListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof mainCenterList>>>
export type MainCenterListInfiniteQueryError = unknown


export function useMainCenterListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof mainCenterList>>, MainCenterListParams['page']>, TError = unknown>(
 params: MainCenterListParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof mainCenterList>>, TError, TData, Awaited<ReturnType<typeof mainCenterList>>, QueryKey, MainCenterListParams['page']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof mainCenterList>>,
          TError,
          TData, QueryKey
        > , 'initialData'
      >, }

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useMainCenterListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof mainCenterList>>, MainCenterListParams['page']>, TError = unknown>(
 params: MainCenterListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof mainCenterList>>, TError, TData, Awaited<ReturnType<typeof mainCenterList>>, QueryKey, MainCenterListParams['page']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof mainCenterList>>,
          TError,
          TData, QueryKey
        > , 'initialData'
      >, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useMainCenterListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof mainCenterList>>, MainCenterListParams['page']>, TError = unknown>(
 params: MainCenterListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof mainCenterList>>, TError, TData, Awaited<ReturnType<typeof mainCenterList>>, QueryKey, MainCenterListParams['page']>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Î©îÏù∏ÏóêÏÑú Ìä∏Î†àÏù¥ÎÑàÍ∞Ä ÏßÄÏ†ïÌïú ÏÑºÌÑ∞ Î™©Î°ù Ï°∞Ìöå API
 */

export function useMainCenterListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof mainCenterList>>, MainCenterListParams['page']>, TError = unknown>(
 params: MainCenterListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof mainCenterList>>, TError, TData, Awaited<ReturnType<typeof mainCenterList>>, QueryKey, MainCenterListParams['page']>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getMainCenterListInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getMainCenterListQueryOptions = <TData = Awaited<ReturnType<typeof mainCenterList>>, TError = unknown>(params: MainCenterListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mainCenterList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMainCenterListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof mainCenterList>>> = ({ signal }) => mainCenterList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof mainCenterList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type MainCenterListQueryResult = NonNullable<Awaited<ReturnType<typeof mainCenterList>>>
export type MainCenterListQueryError = unknown


export function useMainCenterList<TData = Awaited<ReturnType<typeof mainCenterList>>, TError = unknown>(
 params: MainCenterListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof mainCenterList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof mainCenterList>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useMainCenterList<TData = Awaited<ReturnType<typeof mainCenterList>>, TError = unknown>(
 params: MainCenterListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mainCenterList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof mainCenterList>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useMainCenterList<TData = Awaited<ReturnType<typeof mainCenterList>>, TError = unknown>(
 params: MainCenterListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mainCenterList>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Î©îÏù∏ÏóêÏÑú Ìä∏Î†àÏù¥ÎÑàÍ∞Ä ÏßÄÏ†ïÌïú ÏÑºÌÑ∞ Î™©Î°ù Ï°∞Ìöå API
 */

export function useMainCenterList<TData = Awaited<ReturnType<typeof mainCenterList>>, TError = unknown>(
 params: MainCenterListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mainCenterList>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getMainCenterListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Ìä∏Î†àÏù¥ÎÑà Ï†ïÎ≥¥ Ï°∞Ìöå API ÏûÖÎãàÎã§.
 * @summary Ìä∏Î†àÏù¥ÎÑà Ï†ïÎ≥¥ Ï°∞Ìöå API
 */
export const getUserInfo = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosInstance<ApiResponseMessageUserInfoResDto>(
      {url: `/api/v1/user/info`, method: 'GET', signal
    },
      );
    }
  

export const getGetUserInfoQueryKey = () => {
    return [`/api/v1/user/info`] as const;
    }

    
export const getGetUserInfoInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getUserInfo>>>, TError = unknown>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserInfo>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserInfoQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserInfo>>> = ({ signal }) => getUserInfo(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUserInfoInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUserInfo>>>
export type GetUserInfoInfiniteQueryError = unknown


export function useGetUserInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUserInfo>>>, TError = unknown>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserInfo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserInfo>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUserInfo>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserInfo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserInfo>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUserInfo>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserInfo>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Ìä∏Î†àÏù¥ÎÑà Ï†ïÎ≥¥ Ï°∞Ìöå API
 */

export function useGetUserInfoInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUserInfo>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserInfo>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetUserInfoInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUserInfoQueryOptions = <TData = Awaited<ReturnType<typeof getUserInfo>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserInfo>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserInfoQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserInfo>>> = ({ signal }) => getUserInfo(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUserInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getUserInfo>>>
export type GetUserInfoQueryError = unknown


export function useGetUserInfo<TData = Awaited<ReturnType<typeof getUserInfo>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserInfo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserInfo>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserInfo<TData = Awaited<ReturnType<typeof getUserInfo>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserInfo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserInfo>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserInfo<TData = Awaited<ReturnType<typeof getUserInfo>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserInfo>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Ìä∏Î†àÏù¥ÎÑà Ï†ïÎ≥¥ Ï°∞Ìöå API
 */

export function useGetUserInfo<TData = Awaited<ReturnType<typeof getUserInfo>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserInfo>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetUserInfoQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Ìä∏Î†àÏù¥ÎÑàÍ∞Ä ÏßÄÏ†ïÌïú ÏÑºÌÑ∞ Î™©Î°ù Ï°∞Ìöå API ÏûÖÎãàÎã§.
 * @summary Ìä∏Î†àÏù¥ÎÑàÍ∞Ä ÏßÄÏ†ïÌïú ÏÑºÌÑ∞ Î™©Î°ù Ï°∞Ìöå API
 */
export const centerList = (
    params: CenterListParams,
 signal?: AbortSignal
) => {
      
      
      return axiosInstance<ApiResponseMessagePageResponseDtoUserCenterListResDto>(
      {url: `/api/v1/user/centers`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getCenterListQueryKey = (params: CenterListParams,) => {
    return [`/api/v1/user/centers`, ...(params ? [params]: [])] as const;
    }

    
export const getCenterListInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof centerList>>, CenterListParams['page']>, TError = unknown>(params: CenterListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof centerList>>, TError, TData, Awaited<ReturnType<typeof centerList>>, QueryKey, CenterListParams['page']>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCenterListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof centerList>>, QueryKey, CenterListParams['page']> = ({ signal, pageParam }) => centerList({...params, page: pageParam || params?.['page']}, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof centerList>>, TError, TData, Awaited<ReturnType<typeof centerList>>, QueryKey, CenterListParams['page']> & { queryKey: DataTag<QueryKey, TData> }
}

export type CenterListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof centerList>>>
export type CenterListInfiniteQueryError = unknown


export function useCenterListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof centerList>>, CenterListParams['page']>, TError = unknown>(
 params: CenterListParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof centerList>>, TError, TData, Awaited<ReturnType<typeof centerList>>, QueryKey, CenterListParams['page']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof centerList>>,
          TError,
          TData, QueryKey
        > , 'initialData'
      >, }

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCenterListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof centerList>>, CenterListParams['page']>, TError = unknown>(
 params: CenterListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof centerList>>, TError, TData, Awaited<ReturnType<typeof centerList>>, QueryKey, CenterListParams['page']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof centerList>>,
          TError,
          TData, QueryKey
        > , 'initialData'
      >, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCenterListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof centerList>>, CenterListParams['page']>, TError = unknown>(
 params: CenterListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof centerList>>, TError, TData, Awaited<ReturnType<typeof centerList>>, QueryKey, CenterListParams['page']>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Ìä∏Î†àÏù¥ÎÑàÍ∞Ä ÏßÄÏ†ïÌïú ÏÑºÌÑ∞ Î™©Î°ù Ï°∞Ìöå API
 */

export function useCenterListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof centerList>>, CenterListParams['page']>, TError = unknown>(
 params: CenterListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof centerList>>, TError, TData, Awaited<ReturnType<typeof centerList>>, QueryKey, CenterListParams['page']>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getCenterListInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCenterListQueryOptions = <TData = Awaited<ReturnType<typeof centerList>>, TError = unknown>(params: CenterListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof centerList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCenterListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof centerList>>> = ({ signal }) => centerList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof centerList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type CenterListQueryResult = NonNullable<Awaited<ReturnType<typeof centerList>>>
export type CenterListQueryError = unknown


export function useCenterList<TData = Awaited<ReturnType<typeof centerList>>, TError = unknown>(
 params: CenterListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof centerList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof centerList>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCenterList<TData = Awaited<ReturnType<typeof centerList>>, TError = unknown>(
 params: CenterListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof centerList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof centerList>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCenterList<TData = Awaited<ReturnType<typeof centerList>>, TError = unknown>(
 params: CenterListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof centerList>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Ìä∏Î†àÏù¥ÎÑàÍ∞Ä ÏßÄÏ†ïÌïú ÏÑºÌÑ∞ Î™©Î°ù Ï°∞Ìöå API
 */

export function useCenterList<TData = Awaited<ReturnType<typeof centerList>>, TError = unknown>(
 params: CenterListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof centerList>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getCenterListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ÏÑºÌÑ∞ Î™©Î°ù Ï°∞Ìöå API ÏûÖÎãàÎã§.
 * @summary ÏÑºÌÑ∞ Î™©Î°ù Ï°∞Ìöå API
 */
export const centerList1 = (
    params: CenterList1Params,
 signal?: AbortSignal
) => {
      
      
      return axiosInstance<ApiResponseMessagePageResponseDtoCenterListResDto>(
      {url: `/api/v1/user/center/list`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getCenterList1QueryKey = (params: CenterList1Params,) => {
    return [`/api/v1/user/center/list`, ...(params ? [params]: [])] as const;
    }

    
export const getCenterList1InfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof centerList1>>, CenterList1Params['page']>, TError = unknown>(params: CenterList1Params, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof centerList1>>, TError, TData, Awaited<ReturnType<typeof centerList1>>, QueryKey, CenterList1Params['page']>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCenterList1QueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof centerList1>>, QueryKey, CenterList1Params['page']> = ({ signal, pageParam }) => centerList1({...params, page: pageParam || params?.['page']}, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof centerList1>>, TError, TData, Awaited<ReturnType<typeof centerList1>>, QueryKey, CenterList1Params['page']> & { queryKey: DataTag<QueryKey, TData> }
}

export type CenterList1InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof centerList1>>>
export type CenterList1InfiniteQueryError = unknown


export function useCenterList1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof centerList1>>, CenterList1Params['page']>, TError = unknown>(
 params: CenterList1Params, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof centerList1>>, TError, TData, Awaited<ReturnType<typeof centerList1>>, QueryKey, CenterList1Params['page']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof centerList1>>,
          TError,
          TData, QueryKey
        > , 'initialData'
      >, }

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCenterList1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof centerList1>>, CenterList1Params['page']>, TError = unknown>(
 params: CenterList1Params, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof centerList1>>, TError, TData, Awaited<ReturnType<typeof centerList1>>, QueryKey, CenterList1Params['page']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof centerList1>>,
          TError,
          TData, QueryKey
        > , 'initialData'
      >, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCenterList1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof centerList1>>, CenterList1Params['page']>, TError = unknown>(
 params: CenterList1Params, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof centerList1>>, TError, TData, Awaited<ReturnType<typeof centerList1>>, QueryKey, CenterList1Params['page']>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary ÏÑºÌÑ∞ Î™©Î°ù Ï°∞Ìöå API
 */

export function useCenterList1Infinite<TData = InfiniteData<Awaited<ReturnType<typeof centerList1>>, CenterList1Params['page']>, TError = unknown>(
 params: CenterList1Params, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof centerList1>>, TError, TData, Awaited<ReturnType<typeof centerList1>>, QueryKey, CenterList1Params['page']>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getCenterList1InfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCenterList1QueryOptions = <TData = Awaited<ReturnType<typeof centerList1>>, TError = unknown>(params: CenterList1Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof centerList1>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCenterList1QueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof centerList1>>> = ({ signal }) => centerList1(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof centerList1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type CenterList1QueryResult = NonNullable<Awaited<ReturnType<typeof centerList1>>>
export type CenterList1QueryError = unknown


export function useCenterList1<TData = Awaited<ReturnType<typeof centerList1>>, TError = unknown>(
 params: CenterList1Params, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof centerList1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof centerList1>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCenterList1<TData = Awaited<ReturnType<typeof centerList1>>, TError = unknown>(
 params: CenterList1Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof centerList1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof centerList1>>,
          TError,
          TData
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useCenterList1<TData = Awaited<ReturnType<typeof centerList1>>, TError = unknown>(
 params: CenterList1Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof centerList1>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary ÏÑºÌÑ∞ Î™©Î°ù Ï°∞Ìöå API
 */

export function useCenterList1<TData = Awaited<ReturnType<typeof centerList1>>, TError = unknown>(
 params: CenterList1Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof centerList1>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getCenterList1QueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



